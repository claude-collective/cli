import path from "path";
import { parse as parseYaml } from "yaml";
import { readFile, writeFile, ensureDir, glob, fileExists, copy } from "../../utils/fs";
import { verbose, warn } from "../../utils/logger";
import {
  generateSkillPluginManifest,
  writePluginManifest,
  getPluginManifestPath,
} from "../plugins";
import { parseFrontmatter } from "../loading";
import { hashSkillFolder } from "../versioning";
import { DEFAULT_VERSION } from "../../consts";
import type { PluginManifest, SkillFrontmatter, SkillMetadataConfig } from "../../types";
import { skillMetadataConfigSchema, pluginManifestSchema } from "../schemas";

export type SkillPluginOptions = {
  skillPath: string;
  outputDir: string;
  skillName?: string;
};

export type CompiledSkillPlugin = {
  pluginPath: string;
  manifest: PluginManifest;
  skillName: string;
};

const SKILL_FILES = ["SKILL.md", "reference.md"] as const;

const SKILL_DIRS = ["examples", "scripts"] as const;

function sanitizeSkillName(name: string): string {
  return name.replace(/\+/g, "-");
}

function parseMajorVersion(version: string): number {
  const match = version.match(/^(\d+)\./);
  return match ? parseInt(match[1], 10) : 1;
}

function bumpMajorVersion(version: string): string {
  const major = parseMajorVersion(version);
  return `${major + 1}.0.0`;
}

const CONTENT_HASH_FILE = ".content-hash";

async function readExistingManifest(
  pluginDir: string,
): Promise<{ version: string; contentHash: string | undefined } | null> {
  const manifestPath = getPluginManifestPath(pluginDir);

  if (!(await fileExists(manifestPath))) {
    return null;
  }

  try {
    const content = await readFile(manifestPath);
    const manifest = pluginManifestSchema.parse(JSON.parse(content));

    const hashFilePath = manifestPath.replace("plugin.json", CONTENT_HASH_FILE);
    let contentHash: string | undefined;
    if (await fileExists(hashFilePath)) {
      contentHash = (await readFile(hashFilePath)).trim();
    }

    return {
      version: manifest.version ?? DEFAULT_VERSION,
      contentHash,
    };
  } catch {
    return null;
  }
}

async function determineVersion(
  skillPath: string,
  pluginDir: string,
): Promise<{ version: string; contentHash: string }> {
  const newHash = await hashSkillFolder(skillPath);

  const existing = await readExistingManifest(pluginDir);

  if (!existing) {
    return {
      version: DEFAULT_VERSION,
      contentHash: newHash,
    };
  }

  if (existing.contentHash !== newHash) {
    return {
      version: bumpMajorVersion(existing.version),
      contentHash: newHash,
    };
  }

  return {
    version: existing.version,
    contentHash: newHash,
  };
}

async function readSkillMetadata(skillPath: string): Promise<SkillMetadataConfig | null> {
  const metadataPath = path.join(skillPath, "metadata.yaml");

  if (!(await fileExists(metadataPath))) {
    return null;
  }

  try {
    const content = await readFile(metadataPath);
    const lines = content.split("\n");
    const yamlContent = lines[0]?.startsWith("# yaml-language-server:")
      ? lines.slice(1).join("\n")
      : content;

    const result = skillMetadataConfigSchema.safeParse(parseYaml(yamlContent));
    if (!result.success) {
      warn(
        `Invalid metadata.yaml at ${skillPath}: ${result.error.issues.map((i) => `${i.path.join(".")}: ${i.message}`).join("; ")}`,
      );
      return null;
    }
    return result.data;
  } catch {
    return null;
  }
}

function generateReadme(
  skillName: string,
  frontmatter: SkillFrontmatter,
  metadata: SkillMetadataConfig | null,
): string {
  const lines: string[] = [];

  lines.push(`# ${skillName}`);
  lines.push("");
  lines.push(frontmatter.description);
  lines.push("");

  if (metadata?.tags && metadata.tags.length > 0) {
    lines.push("## Tags");
    lines.push("");
    lines.push(metadata.tags.map((t) => `\`${t}\``).join(" "));
    lines.push("");
  }

  lines.push("## Installation");
  lines.push("");
  lines.push("Add this plugin to your Claude Code configuration:");
  lines.push("");
  lines.push("```json");
  lines.push(`{`);
  lines.push(`  "plugins": ["skill-${skillName}"]`);
  lines.push(`}`);
  lines.push("```");
  lines.push("");

  lines.push("## Usage");
  lines.push("");
  lines.push(`This skill is automatically available when installed.`);
  if (metadata?.requires && metadata.requires.length > 0) {
    lines.push("");
    lines.push("**Requires:** " + metadata.requires.join(", "));
  }
  lines.push("");

  lines.push("---");
  lines.push("");
  lines.push("*Generated by Claude Collective skill-plugin-compiler*");
  lines.push("");

  return lines.join("\n");
}

export async function compileSkillPlugin(
  options: SkillPluginOptions,
): Promise<CompiledSkillPlugin> {
  const { skillPath, outputDir, skillName: overrideName } = options;

  // Use directory basename for initial error messages before frontmatter is parsed
  const dirBasename = path.basename(skillPath);

  const skillMdPath = path.join(skillPath, "SKILL.md");
  if (!(await fileExists(skillMdPath))) {
    throw new Error(
      `Skill '${dirBasename}' is missing required SKILL.md file. Expected at: ${skillMdPath}`,
    );
  }

  const skillMdContent = await readFile(skillMdPath);
  const frontmatter = parseFrontmatter(skillMdContent, skillMdPath);

  if (!frontmatter) {
    throw new Error(
      `Skill '${dirBasename}' has invalid or missing YAML frontmatter in SKILL.md. ` +
        `Required fields: 'name' and 'description'. File: ${skillMdPath}`,
    );
  }

  // Use frontmatter.name as the canonical skill name (source of truth)
  // Override name takes precedence if explicitly provided
  const skillName = overrideName ?? sanitizeSkillName(frontmatter.name);

  verbose(`Compiling skill plugin: ${skillName} from ${skillPath}`);

  const metadata = await readSkillMetadata(skillPath);

  const pluginDir = path.join(outputDir, `skill-${skillName}`);
  const skillsDir = path.join(pluginDir, "skills", skillName);

  await ensureDir(pluginDir);
  await ensureDir(skillsDir);

  const { version, contentHash } = await determineVersion(skillPath, pluginDir);

  const manifest = generateSkillPluginManifest({
    skillName,
    description: frontmatter.description,
    author: metadata?.author,
    version,
    keywords: metadata?.tags,
  });

  await writePluginManifest(pluginDir, manifest);

  const hashFilePath = getPluginManifestPath(pluginDir).replace("plugin.json", CONTENT_HASH_FILE);
  await writeFile(hashFilePath, contentHash);

  verbose(`  Wrote plugin.json for ${skillName} (v${version})`);

  await writeFile(path.join(skillsDir, "SKILL.md"), skillMdContent);
  verbose(`  Copied SKILL.md`);

  for (const fileName of SKILL_FILES) {
    if (fileName === "SKILL.md") continue;

    const sourcePath = path.join(skillPath, fileName);
    if (await fileExists(sourcePath)) {
      const content = await readFile(sourcePath);
      await writeFile(path.join(skillsDir, fileName), content);
      verbose(`  Copied ${fileName}`);
    }
  }

  for (const dirName of SKILL_DIRS) {
    const sourceDir = path.join(skillPath, dirName);
    if (await fileExists(sourceDir)) {
      await copy(sourceDir, path.join(skillsDir, dirName));
      verbose(`  Copied ${dirName}/`);
    }
  }

  const readme = generateReadme(skillName, frontmatter, metadata);
  await writeFile(path.join(pluginDir, "README.md"), readme);
  verbose(`  Generated README.md`);

  return {
    pluginPath: pluginDir,
    manifest,
    skillName,
  };
}

export async function compileAllSkillPlugins(
  skillsDir: string,
  outputDir: string,
): Promise<CompiledSkillPlugin[]> {
  const results: CompiledSkillPlugin[] = [];

  const skillMdFiles = await glob("**/SKILL.md", skillsDir);

  for (const skillMdFile of skillMdFiles) {
    const skillPath = path.join(skillsDir, path.dirname(skillMdFile));

    try {
      // compileSkillPlugin uses frontmatter.name as the canonical skill name
      const result = await compileSkillPlugin({
        skillPath,
        outputDir,
      });
      results.push(result);
      console.log(`  [OK] skill-${result.skillName}`);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      const dirBasename = path.basename(skillPath);
      console.warn(`  [WARN] Failed to compile skill from ${dirBasename}: ${errorMessage}`);
    }
  }

  return results;
}

export function printCompilationSummary(results: CompiledSkillPlugin[]): void {
  console.log(`\nCompiled ${results.length} skill plugins:`);
  for (const result of results) {
    console.log(`  - skill-${result.skillName} (v${result.manifest.version})`);
  }
}
