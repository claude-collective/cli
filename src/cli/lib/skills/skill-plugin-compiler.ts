import path from "path";
import { parse as parseYaml } from "yaml";
import { getErrorMessage } from "../../utils/errors";
import { readFile, writeFile, ensureDir, glob, fileExists, copy } from "../../utils/fs";
import { log, verbose, warn } from "../../utils/logger";
import {
  generateSkillPluginManifest,
  writePluginManifest,
  getPluginManifestPath,
} from "../plugins";
import { parseFrontmatter } from "../loading";
import { computeSkillFolderHash, determinePluginVersion, writeContentHash } from "../versioning";
import type { PluginManifest, SkillFrontmatter, SkillMetadataConfig } from "../../types";
import { formatZodErrors, skillMetadataLoaderSchema } from "../schemas";
import { DEFAULT_BRANDING, STANDARD_FILES } from "../../consts";
import { SKILL_CONTENT_FILES, SKILL_CONTENT_DIRS } from "../metadata-keys";

export type SkillPluginOptions = {
  skillPath: string;
  outputDir: string;
  skillName?: string;
};

export type CompiledSkillPlugin = {
  pluginPath: string;
  manifest: PluginManifest;
  skillName: string;
};

function sanitizeSkillName(name: string): string {
  return name.replace(/\+/g, "-");
}

async function readSkillMetadata(skillPath: string): Promise<SkillMetadataConfig | null> {
  const metadataPath = path.join(skillPath, STANDARD_FILES.METADATA_YAML);

  if (!(await fileExists(metadataPath))) {
    return null;
  }

  try {
    const content = await readFile(metadataPath);
    const lines = content.split("\n");
    const yamlContent = lines[0]?.startsWith("# yaml-language-server:")
      ? lines.slice(1).join("\n")
      : content;

    const result = skillMetadataLoaderSchema.safeParse(parseYaml(yamlContent));
    if (!result.success) {
      warn(`Invalid metadata.yaml at '${skillPath}': ${formatZodErrors(result.error.issues)}`);
      return null;
    }
    return result.data;
  } catch (error) {
    warn(`Failed to read metadata.yaml at '${skillPath}': ${error}`);
    return null;
  }
}

function generateReadme(
  skillName: string,
  frontmatter: SkillFrontmatter,
  metadata: SkillMetadataConfig | null,
): string {
  const lines: string[] = [];

  lines.push(`# ${skillName}`);
  lines.push("");
  lines.push(frontmatter.description);
  lines.push("");

  if (metadata?.tags && metadata.tags.length > 0) {
    lines.push("## Tags");
    lines.push("");
    lines.push(metadata.tags.map((t) => `\`${t}\``).join(" "));
    lines.push("");
  }

  lines.push("## Installation");
  lines.push("");
  lines.push("Add this plugin to your Claude Code configuration:");
  lines.push("");
  lines.push("```json");
  lines.push("{");
  lines.push(`  "plugins": ["${skillName}"]`);
  lines.push("}");
  lines.push("```");
  lines.push("");

  lines.push("## Usage");
  lines.push("");
  lines.push("This skill is automatically available when installed.");
  if (metadata?.requires && metadata.requires.length > 0) {
    lines.push("");
    lines.push(`**Requires:** ${metadata.requires.join(", ")}`);
  }
  lines.push("");

  lines.push("---");
  lines.push("");
  lines.push(`*Generated by ${DEFAULT_BRANDING.NAME} skill-plugin-compiler*`);
  lines.push("");

  return lines.join("\n");
}

export async function compileSkillPlugin(
  options: SkillPluginOptions,
): Promise<CompiledSkillPlugin> {
  const { skillPath, outputDir, skillName: overrideName } = options;

  const dirBasename = path.basename(skillPath);

  const skillMdPath = path.join(skillPath, STANDARD_FILES.SKILL_MD);
  if (!(await fileExists(skillMdPath))) {
    throw new Error(
      `Skill '${dirBasename}' is missing required ${STANDARD_FILES.SKILL_MD} file. Expected at: ${skillMdPath}`,
    );
  }

  const skillMdContent = await readFile(skillMdPath);
  const frontmatter = parseFrontmatter(skillMdContent, skillMdPath);

  if (!frontmatter) {
    throw new Error(
      `Skill '${dirBasename}' has invalid or missing YAML frontmatter in ${STANDARD_FILES.SKILL_MD}. ` +
        `Required fields: 'name' and 'description'. File: ${skillMdPath}`,
    );
  }

  const skillName = overrideName ?? sanitizeSkillName(frontmatter.name);

  verbose(`Compiling skill plugin: ${skillName} from ${skillPath}`);

  const metadata = await readSkillMetadata(skillPath);

  const pluginDir = path.join(outputDir, skillName);
  const skillsDir = path.join(pluginDir, "skills", skillName);

  await ensureDir(pluginDir);
  await ensureDir(skillsDir);

  const newHash = await computeSkillFolderHash(skillPath);
  const { version, contentHash } = await determinePluginVersion(
    newHash,
    pluginDir,
    getPluginManifestPath,
  );

  const manifest = generateSkillPluginManifest({
    skillName,
    description: frontmatter.description,
    author: metadata?.author,
    version,
    keywords: metadata?.tags,
  });

  await writePluginManifest(pluginDir, manifest);

  await writeContentHash(pluginDir, contentHash, getPluginManifestPath);

  verbose(`  Wrote plugin.json for ${skillName} (v${version})`);

  await writeFile(path.join(skillsDir, STANDARD_FILES.SKILL_MD), skillMdContent);
  verbose(`  Copied ${STANDARD_FILES.SKILL_MD}`);

  for (const fileName of SKILL_CONTENT_FILES) {
    if (fileName === STANDARD_FILES.SKILL_MD) continue;

    const sourcePath = path.join(skillPath, fileName);
    if (await fileExists(sourcePath)) {
      const content = await readFile(sourcePath);
      await writeFile(path.join(skillsDir, fileName), content);
      verbose(`  Copied ${fileName}`);
    }
  }

  for (const dirName of SKILL_CONTENT_DIRS) {
    const sourceDir = path.join(skillPath, dirName);
    if (await fileExists(sourceDir)) {
      await copy(sourceDir, path.join(skillsDir, dirName));
      verbose(`  Copied ${dirName}/`);
    }
  }

  const readme = generateReadme(skillName, frontmatter, metadata);
  await writeFile(path.join(pluginDir, "README.md"), readme);
  verbose("  Generated README.md");

  return {
    pluginPath: pluginDir,
    manifest,
    skillName,
  };
}

export async function compileAllSkillPlugins(
  skillsDir: string,
  outputDir: string,
): Promise<CompiledSkillPlugin[]> {
  const results: CompiledSkillPlugin[] = [];

  const skillMdFiles = await glob(`**/${STANDARD_FILES.SKILL_MD}`, skillsDir);

  for (const skillMdFile of skillMdFiles) {
    const skillPath = path.join(skillsDir, path.dirname(skillMdFile));

    try {
      const result = await compileSkillPlugin({
        skillPath,
        outputDir,
      });
      results.push(result);
      log(`  [OK] ${result.skillName}`);
    } catch (error) {
      const errorMessage = getErrorMessage(error);
      const dirBasename = path.basename(skillPath);
      warn(`Failed to compile skill from '${dirBasename}': ${errorMessage}`);
    }
  }

  return results;
}

export function printCompilationSummary(results: CompiledSkillPlugin[]): void {
  log(`\nCompiled ${results.length} skill plugins:`);
  for (const result of results) {
    log(`  - ${result.skillName} (v${result.manifest.version})`);
  }
}
