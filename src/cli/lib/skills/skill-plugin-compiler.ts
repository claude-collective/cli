import path from "path";
import { parse as parseYaml } from "yaml";
import { readFile, writeFile, ensureDir, glob, fileExists, copy } from "../../utils/fs";
import { verbose, warn } from "../../utils/logger";
import {
  generateSkillPluginManifest,
  writePluginManifest,
  getPluginManifestPath,
} from "../plugins";
import { parseFrontmatter } from "../loading";
import { hashSkillFolder, determinePluginVersion, writeContentHash } from "../versioning";
import type { PluginManifest, SkillFrontmatter, SkillMetadataConfig } from "../../types";
import { skillMetadataLoaderSchema } from "../schemas";

export type SkillPluginOptions = {
  skillPath: string;
  outputDir: string;
  skillName?: string;
};

export type CompiledSkillPlugin = {
  pluginPath: string;
  manifest: PluginManifest;
  skillName: string;
};

const SKILL_FILES = ["SKILL.md", "reference.md"] as const;

const SKILL_DIRS = ["examples", "scripts"] as const;

function sanitizeSkillName(name: string): string {
  return name.replace(/\+/g, "-");
}

async function readSkillMetadata(skillPath: string): Promise<SkillMetadataConfig | null> {
  const metadataPath = path.join(skillPath, "metadata.yaml");

  if (!(await fileExists(metadataPath))) {
    return null;
  }

  try {
    const content = await readFile(metadataPath);
    const lines = content.split("\n");
    const yamlContent = lines[0]?.startsWith("# yaml-language-server:")
      ? lines.slice(1).join("\n")
      : content;

    const result = skillMetadataLoaderSchema.safeParse(parseYaml(yamlContent));
    if (!result.success) {
      warn(
        `Invalid metadata.yaml at ${skillPath}: ${result.error.issues.map((i) => `${i.path.join(".")}: ${i.message}`).join("; ")}`,
      );
      return null;
    }
    return result.data;
  } catch (error) {
    warn(`Failed to read metadata.yaml at ${skillPath}: ${error}`);
    return null;
  }
}

function generateReadme(
  skillName: string,
  frontmatter: SkillFrontmatter,
  metadata: SkillMetadataConfig | null,
): string {
  const lines: string[] = [];

  lines.push(`# ${skillName}`);
  lines.push("");
  lines.push(frontmatter.description);
  lines.push("");

  if (metadata?.tags && metadata.tags.length > 0) {
    lines.push("## Tags");
    lines.push("");
    lines.push(metadata.tags.map((t) => `\`${t}\``).join(" "));
    lines.push("");
  }

  lines.push("## Installation");
  lines.push("");
  lines.push("Add this plugin to your Claude Code configuration:");
  lines.push("");
  lines.push("```json");
  lines.push(`{`);
  lines.push(`  "plugins": ["${skillName}"]`);
  lines.push(`}`);
  lines.push("```");
  lines.push("");

  lines.push("## Usage");
  lines.push("");
  lines.push(`This skill is automatically available when installed.`);
  if (metadata?.requires && metadata.requires.length > 0) {
    lines.push("");
    lines.push("**Requires:** " + metadata.requires.join(", "));
  }
  lines.push("");

  lines.push("---");
  lines.push("");
  lines.push("*Generated by Claude Collective skill-plugin-compiler*");
  lines.push("");

  return lines.join("\n");
}

export async function compileSkillPlugin(
  options: SkillPluginOptions,
): Promise<CompiledSkillPlugin> {
  const { skillPath, outputDir, skillName: overrideName } = options;

  // Use directory basename for initial error messages before frontmatter is parsed
  const dirBasename = path.basename(skillPath);

  const skillMdPath = path.join(skillPath, "SKILL.md");
  if (!(await fileExists(skillMdPath))) {
    throw new Error(
      `Skill '${dirBasename}' is missing required SKILL.md file. Expected at: ${skillMdPath}`,
    );
  }

  const skillMdContent = await readFile(skillMdPath);
  const frontmatter = parseFrontmatter(skillMdContent, skillMdPath);

  if (!frontmatter) {
    throw new Error(
      `Skill '${dirBasename}' has invalid or missing YAML frontmatter in SKILL.md. ` +
        `Required fields: 'name' and 'description'. File: ${skillMdPath}`,
    );
  }

  // Use frontmatter.name as the canonical skill name (source of truth)
  // Override name takes precedence if explicitly provided
  const skillName = overrideName ?? sanitizeSkillName(frontmatter.name);

  verbose(`Compiling skill plugin: ${skillName} from ${skillPath}`);

  const metadata = await readSkillMetadata(skillPath);

  const pluginDir = path.join(outputDir, skillName);
  const skillsDir = path.join(pluginDir, "skills", skillName);

  await ensureDir(pluginDir);
  await ensureDir(skillsDir);

  const newHash = await hashSkillFolder(skillPath);
  const { version, contentHash } = await determinePluginVersion(
    newHash,
    pluginDir,
    getPluginManifestPath,
  );

  const manifest = generateSkillPluginManifest({
    skillName,
    description: frontmatter.description,
    author: metadata?.author,
    version,
    keywords: metadata?.tags,
  });

  await writePluginManifest(pluginDir, manifest);

  await writeContentHash(pluginDir, contentHash, getPluginManifestPath);

  verbose(`  Wrote plugin.json for ${skillName} (v${version})`);

  await writeFile(path.join(skillsDir, "SKILL.md"), skillMdContent);
  verbose(`  Copied SKILL.md`);

  for (const fileName of SKILL_FILES) {
    if (fileName === "SKILL.md") continue;

    const sourcePath = path.join(skillPath, fileName);
    if (await fileExists(sourcePath)) {
      const content = await readFile(sourcePath);
      await writeFile(path.join(skillsDir, fileName), content);
      verbose(`  Copied ${fileName}`);
    }
  }

  for (const dirName of SKILL_DIRS) {
    const sourceDir = path.join(skillPath, dirName);
    if (await fileExists(sourceDir)) {
      await copy(sourceDir, path.join(skillsDir, dirName));
      verbose(`  Copied ${dirName}/`);
    }
  }

  const readme = generateReadme(skillName, frontmatter, metadata);
  await writeFile(path.join(pluginDir, "README.md"), readme);
  verbose(`  Generated README.md`);

  return {
    pluginPath: pluginDir,
    manifest,
    skillName,
  };
}

export async function compileAllSkillPlugins(
  skillsDir: string,
  outputDir: string,
): Promise<CompiledSkillPlugin[]> {
  const results: CompiledSkillPlugin[] = [];

  const skillMdFiles = await glob("**/SKILL.md", skillsDir);

  for (const skillMdFile of skillMdFiles) {
    const skillPath = path.join(skillsDir, path.dirname(skillMdFile));

    try {
      // compileSkillPlugin uses frontmatter.name as the canonical skill name
      const result = await compileSkillPlugin({
        skillPath,
        outputDir,
      });
      results.push(result);
      console.log(`  [OK] ${result.skillName}`);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      const dirBasename = path.basename(skillPath);
      console.warn(`  [WARN] Failed to compile skill from ${dirBasename}: ${errorMessage}`);
    }
  }

  return results;
}

export function printCompilationSummary(results: CompiledSkillPlugin[]): void {
  console.log(`\nCompiled ${results.length} skill plugins:`);
  for (const result of results) {
    console.log(`  - ${result.skillName} (v${result.manifest.version})`);
  }
}
